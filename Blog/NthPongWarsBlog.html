<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1">
<META NAME="author" CONTENT="Alexander G. M. Smith">
<TITLE>NABU Nth Pong Wars Blog</TITLE>
</HEAD>
<BODY BGCOLOR="WHITE" TEXT="BLACK" LINK="BLUE" VLINK="SILVER">

<H1>NABU Nth Pong Wars Blog</H1>

<P>I'm trying to write an improved version of <I>Pong Wars</I> for the NABU as
a project to become familiar with NABU programming.  Then maybe I can do a
fancy Miniputt golf game.

<P ALIGN=CENTER><IMG SRC="Pong_Wars_Koen_van_Gilst_version_20240207.png"
ALT="[Screen shot of Pong Wars, Koen van Gilst version]" WIDTH="651"
HEIGHT="687">

<P><I>Pong Wars</I> is a game with a board of <I>width</I> by <I>height</I>
squares and two balls of different colours (black and white usually).
Conveniently, the NABU video display is 32 "characters" wide by 24 rows tall,
and if we use a square rather than a letter in the font, that can be our board.
It's also easily controlled in that mode (rather than fiddling with pixels and
VDP bandwidth limits) and we can do the balls as sprites.

<P>The balls move, controlled by inertia until they hit a square of a colour
that doesn't match the ball's colour.  In that case, the square changes to the
ball's colour and the ball's trajectory reflects (bounces) off the square.  The
balls also bounce off the walls as you would expect.

<P>I'd like to add a ball on ball collision explosion to the game, as they
sometimes get stuck when near each other under the standard rules.  Also, user
input via joystick to accelerate the balls in a selected direction (other games
added paddles but that seems less fun, and for precision really needs paddle
controls rather than joysticks).  And sound effects.  And up to 8 balls (thus
the N in the title, for N up to 8 :-).  And network play with other versions of
the program, possibly running on different types of computer.

<H2>2024.02.07</H2>

<P>After spending an hour last week investigating emulating the <A
HREF="https://en.wikipedia.org/wiki/NABU_Network">NABU personal computer</A> in
hopes of writing something for it, I've decided to keep notes in this blog.  So
that I can remember what happened, and other people can start NABU development
too.

<P>First of course, I was reading some online web site documentation.  Of note are:
<UL>
  <LI><B>NABU RetroNET</B> <A HREF="https://nabu.ca/">https://nabu.ca/</A> - the main site for Nabu software, documentation and preservation of Nabu history.
  <LI><B>The NABU Network</B> <A HREF="https://www.nabunetwork.com/">https://www.nabunetwork.com/</A> - a copy-cat rival site of all things Nabu, notable for news.
  <LI><B>Links</B> <A HREF="https://gtamp.com/nabu/">https://gtamp.com/nabu/</A> - a page of links to Nabu emulators, Internet Adapter software varieties, forums.
  <LI><B>NABU-Library</B> <A HREF="https://github.com/DJSures/NABU-LIB">https://github.com/DJSures/NABU-LIB</A> - is a code library by D. J. Sures to make writing NABU programs easier, targeting both CP/M and bare NABU systems.
  <LI><B>Z88DK</B> <A HREF="https://z88dk.org/site/">https://z88dk.org/site/</A> - is a C compiler and assembler for a large variety of Z80 CPU computers.
  <LI><B>SDCC</B> <A HREF="https://sdcc.sourceforge.net/">https://sdcc.sourceforge.net/</A> the Small Device C Compiler used by ZCC.
  <LI><B><I>Pong Wars</I> Discussions</B> on <A HREF="https://news.ycombinator.com/item?id=39159418">Y Combinator</A> and <A HREF="https://hachyderm.io/@vnglst/111828811496422610">Mastodon</A>.  <I>Pong Wars</I> has been around for a while, as these discussions uncover.  Some people want to port it to older 8 bit computers too.
  <LI><B>Javascript version of <I>Pong Wars</I></B> <A HREF="https://pong-wars.koenvangilst.nl/">https://pong-wars.koenvangilst.nl/</A> - Play Koen van Gilst's version of <I>Pong Wars</I> in your web browser.  This web page inspired the Nth Pong Wars project.
  <LI><B>Source code for <I>Pong Wars</I></B> <A HREF="https://github.com/vnglst/pong-wars">https://github.com/vnglst/pong-wars</A> - Javascript, MIT license.  Also see the list of other known versions at the bottom of the page (good gamification ideas in the Atari 2600 version).
</UL>

<P>Then I spent some time reading the source code of the various
implementations of <I>Pong Wars</I> from the
<A HREF="https://github.com/vnglst/pong-wars?tab=readme-ov-file#alternate-version">list
on Github</A>.  The bugs and feature requests list for Koen's version also
suggest a few ideas and improvements.  Odd that they all iterate over the whole
array of squares to draw the screen repeatedly, rather than just doing changed
squares.  A sign of having too much CPU power!

<H2>Setting up a Development Environment</H2>

<P>I'm using Fedora 39 Linux.  Fortunately a lot of the needed tools have
already been packaged.

<H3>Install MAME</H3>

<P>So to install MAME (an emulator which handles the NABU, currently version
0.262):<BR>
<CODE>dnf install mame mame-data-software-lists mame-doc mame-tools</CODE>

<H3>C Compiler</H3>

<P>And for the C compiler and assembler:<BR>
<CODE>dnf install z88dk</CODE><BR>
(actually, that doesn't work, no NABU subsystem, see later on for a source code
based install)

<H3>Network Simulator</H3>

<P>For the NABU Network Adapter server (simulates the NABU network distributing
files to NABU computers), I'm starting with the one from Nabu.ca:

<OL>
  <LI>Download the appropriate one (Linux x86 for me) from
    <A HREF="https://nabu.ca/downloads-nabu-internet-adapter">https://nabu.ca/downloads-nabu-internet-adapter</A>
  <LI>Unzip it and move the files to ~/bin/ or somewhere in your path.
  <LI>Add a link named ~/bin/libdl.so that points to the actual location and
    file of that dynamic loader library.  Using the command "locate libdl", I
    found it at /usr/lib64/libdl.so.2
  <LI>Test it by typing NABU-Internet-Adapter-84 in a Terminal window.  It
    should draw a nice text mode user interface (make Terminal window bigger to
    see more).  Arrow keys, tab and Enter let you navigate around the menus.
    It seems to save files in ~/NABU Internet Adapter/
</OL>

<P>And that's as far as I have gotten.  Hope to run MAME next and see the stock
NABU boot screen.

<HR>

<H2>2024.02.12</H2>

<H3>MAME Not Working</H3>

<P>I started MAME setup by copying some of the files from
GTAMPs "nabu-mame.zip" for Windows into a new MAME directory in my user account.
I was looking for configuration and other similar files, which weren't specific
to the Windows OS MAME that the .zip file includes.  I also converted the
nabu.cmd batch file into a NabuStart.sh bash script file.

<P>Boots, but doesn't run the network - RetroNet adapter says it got FF rather
than some start sequence.  Later on I found it was due to a low baud rate
setting on the simulated serial port that the NABU talks to the NABU network
adapter.

<H3>Try nabud instead:</H3>

<P>Add "nabu" user and group.<BR>
<CODE>useradd --create-home --comment "NABU Network Server" nabu</CODE>

<P>Add to dialout group, in case we ever have a real serial port.<BR>
<CODE>gpasswd --add nabu dialout</CODE>

<P>Add a password.<BR>
<CODE>passwd nabu</CODE>

<P>Log in as nabu user.  Get the source code:<BR>
<CODE>git clone https://github.com/thorpej/nabud.git</CODE><BR>
Then run "./configure", "make", and as root "make install" in the nabud
directory.

<P>After all that, "man nabud" should give you the documentation, and there's a
README on the GitHub page.
<A HREF="https://github.com/thorpej/nabud">https://github.com/thorpej/nabud</A>

<P>Install Linux systemd settings for nabud by doing:<BR>
<CODE>cp -v /usr/local/share/nabud/systemd/nabud.service /etc/systemd/system/</CODE><BR>
Put a configuration file nabud.conf in /usr/local/etc/nabud.conf (trimmed down
from one of the examples).<BR>
Then you can "systemctl status nabud", and use the enable and stop/restart
commands as desired.

<P>Then I tried it again, and get "Got unexpected message 0xff".  Same problem
as with Nabu.ca Network Adapter.  Maybe MAME needs a newer version or different
ROMS or settings (actually was serial port speed).

<H2>2024.02.20</H2>

<H3>Look for ROMs and config files for MAME</H3>

<P>Known working config for MAME found in
<A HREF="https://forums.nabu.ca/viewtopic.php?t=17">https://forums.nabu.ca/viewtopic.php?t=17</A>.

<P>ROMs in the Quiver at Nabu.ca are the same as in the GTAMPs "nabu-mame.zip"
But there's a mention in the Nabu.ca forums that ROM version 14 is a hacked up
version, possibly adding to the communication protocols?  Discussion found at
<A HREF="https://forums.nabu.ca/viewtopic.php?p=951">https://forums.nabu.ca/viewtopic.php?p=951</A>.
Turns out to be the same as the GTAMP nabupc-u53-ver14-2732.bin file.

<P>Noticed that in the other .cmd files from GTAMP, some start MAME with a
<CODE>-bios ver14</CODE> argument, or ver17.

<H2>2024.02.21</H2>

<H3>Serial Port Settings?</H3>

<P>From a post on the Vintage Computer Federation
<A HREF="https://forum.vcfed.org/index.php?threads/nabu-pc-emulation-under-mame.1241092/page-16">https://forum.vcfed.org/index.php?threads/nabu-pc-emulation-under-mame.1241092/page-16</A>
they mentioned setting the baud rate in the emulator to 111900, and that the
<B>Scroll Lock</B> key followed by Tab can bring up the MAME menu when running
(so that you can change the serial port speed).  Mine was at 9600 baud.  And of
course there's no scroll lock key on my laptop keyboard, so I had to dig up a
USB keyboard just to press that button.

<P>How about the other serial port settings?
<A HREF="https://forums.bannister.org/ubbthreads.php?ubb=showflat&Number=122002">https://forums.bannister.org/ubbthreads.php?ubb=showflat&Number=122002</A>
says 111900 baud in both directions, 8 bits, no parity, 1 stop bit, no flow
control.  Still didn't work.

<H3>Start Over!</H3>

<P>I wiped out my MAME directory and restored it from GTAMP's .zip file.  MAME
complained about not finding a keyboard rom; I just had to move the
nabukeyboard*.bin files out from the roms/nabu_kb directory into roms/nabupc.
MAME stopped complaining about missing ROMs and it started working!  Using the
-bios option to pick a rom was apparently causing problems, I just needed to
use the defaults.  Argh!

<P>This command line works (after you get to the MAME menu via the scroll-lock
and tab key, and fix the serial port settings, and have one of the Nabu Network
simulators running in the background on TCP port 5816).  By the way, you can
make the window dimensions larger or smaller as you wish for readability:<BR>
<CODE>mame nabupc -window -resolution 1024x768 -hcca null_modem -bitb socket.127.0.0.1:5816</CODE>

<P>It even worked with both Network Adapter simulators, nabud and the Nabu.ca
NABU Internet Adapter.

<P>Next up, try compiling an example program and get it running.

<H2>2024.02.27</H2>

<H3>How to Compile?</H3>

<P>After a bit of reading and then trying out CP/M (manual and reference card
PDFs exist) in a simulated NABU computer running in MAME, I'm ready to start
programming.  I'm looking at <A
HREF="https://github.com/DJSures/NABU-LIB">https://github.com/DJSures/NABU-LIB</A>
which documents how to set up a development environment and how to compile
programs for the NABU.  Looks like the best way to run the game is under CP/M,
rather than on bare hardware.  That way you can save games to disk, there's
library code for running the hardware (text, graphics, sound, joysticks, serial
data, interrupts, disk access, network access).  Hopefully that will make it
easier to get started with writing the game.

<H2>2024.03.03</H2>

<P>Try to get the compiler working.  Of course, it doesn't, get warnings about
#warning statements in the library's header file.  Hours of frustration ensue.

<P>Try a Hello World simple C program.  Can't find zpragma command.  Try again,
with zcc environment variables set to /usr/share/z88dk/... can't find nabu.cfg.
But can find cpm.cfg.  Look at arguments, turn off "-vn" which hides what zcc
is doing!

<PRE>cp /usr/share/z88dk/lib/config/../..//lib/cpm_crt0.opt /tmp/tmpXXxzT5zg.opt
cp /tmp/tmpXXxzT5zg.opt /tmp/tmpXXxzT5zg.asm
zcpp -I. -DZ80 -DCPM -D__CPM__  -DZ88DK_USES_SDCC=1 -I/usr/share/z88dk/lib/config/../..//include  main.c /tmp/tmpXXFsyuOI.i2
zpragma  < /tmp/tmpXXFsyuOI.i2 > /tmp/tmpXXFsyuOI.i
sh: line 1: zpragma: command not found</PRE>

<P>Looks like it does really need a zpragma command, and none exists.
Deinstall ZCC with <CODE>dnf remove z88dk</CODE> and then download the source
and build zcc and sdcc.  Instructions at
<A HREF="https://github.com/z88dk/z88dk/wiki/installation">https://github.com/z88dk/z88dk/wiki/installation</A>.
I just did a home directory install (not a system-wide install) of the
March 3 2024 version (plenty of older versions are around and there's a
Git repository too for easier reversions, might want to use 2.3 from 20.12.2023
which was before a SDCC compiler change, though I see a NABU change in
February 2024).

<P><CODE>git clone --recursive  https://github.com/z88dk/z88dk.git<BR>
dnf install gcc g++ gdb make bison flex libxml2-devel subversion zlib-devel m4
ragel re2c dos2unix texinfo texi2html curl perl cpanminus ccache boost
boost-devel boost-graph perl-Modern-Perl perl-YAML-LibYAML perl-local-lib
perl-Capture-Tiny perl-Path-Tiny perl-Text-Table perl-Data-HexDump
perl-Regexp-Common perl-Clone perl-File-Slurp pkg-config gmp-devel</CODE>

<P>Then continue on with the rest of the instructions, installing Perl modules,
running the build, and adding environment variables to your .bashrc so ZCC is
runnable.  Finally do their test compile and try a NABU CP/M Hello World.

<P>The tools to make a hard drive disk image for remote access are Windows
versions, so instead copy the .COM file to <I>NABU Internet
Adapter/Store/D/0</I> and see if it shows up in Cloud CP/M on drive D user 0.
Need to use the "CPMDRIVE B" command within the NABU emulation, then it
appears.

<P>Yay!  After 4 hours, got my Hello world test working.  Whew.  That's enough
for today.  Next, try compiling NABU hardware library stuff and see if the
example games work.

<H2>2024.03.04</H2>

<H3>Regressing Z88DK to Compile NABU-LIB and DJ's Examples</H3>

<P>I tried compiling <I>Brick Battle</I>, but lots of errors appear in the
NABU-LIB code; you see this many times:
<PRE>main.c:742: warning 283: function declarator with no prototype
main.c:855: error: syntax error
  ^---- ld ( 0xff00 ), hl
      ^---- ldh(0),hl
</PRE>

<P>The forums <A
HREF="https://forums.nabu.ca/viewtopic.php?t=207">https://forums.nabu.ca/viewtopic.php?t=207</A>
say something broke in Z88DK in May 2023.  A hint: the left over listings of
working code examples in NABU-LIB use version 4.2 of the SDCC compiler.

<P>So first try compiling z88dk release 2.3 (December 20 2023), from this
particular commit: <A
HREF="https://github.com/z88dk/z88dk/commit/51889e53005df1258e1a437bc68e6c4f33b63786">https://github.com/z88dk/z88dk/commit/51889e53005df1258e1a437bc68e6c4f33b63786</A>
and see what version of the compiler it has.  4.3.0 is the version, too new,
and it doesn't work just as before.

<P>Go back in Git history and get Z88DK from May.  Actually, it looks like the
switch to SDCC 4.3.0 was done on February 6 2023, so try the change just before
it, from February 3rd <CODE>git checkout -b NABU-LIB-Compatible
--recurse-submodules 492cb971987d88f91d2b046ce99d5bd34f6fadea</CODE>.  The
build process fetches http://nightly.z88dk.org/zsdcc/zsdcc_r13131_src.tar.gz
(hmmm, actual version number is slightly earlier).  And when compiled, it
compiles without silly errors!  The listing says:<BR>
<CODE>Version 4.2.0 #13081 (Linux)</CODE>

<P>Now does it run?  I see that it loads the title screen picture off the
Nabu.ca network (it's in a subdirectory too).  And music is included as
compiled data.  Yay!  Music and title screen.  Plays with sound effects and
everything in MAME, and exits nicely to CP/M too.  Okay, we're finally in
business after yet another long afternoon trying to get the build system
working.  Whew!

<P>Shortcut to build the right version of Z88DK in one shot (after installing
the software the builder needs) under Linux:<BR>
<CODE>git clone https://github.com/z88dk/z88dk.git ; cd z88dk ; git checkout -b NABU-LIB-Compatible 492cb971987d88f91d2b046ce99d5bd34f6fadea ; git submodule update --init --recursive ; export BUILD_SDCC=1 ; export BUILD_SDCC_HTTP=1 ; ./build.sh ; cd ..</CODE>

<H2>2024.03.05</H2>

<P>Look at the later NABU bug fix in 2859b2b64b5797f2eb4bf944785423a801b40e0c,
but that seems to use a whole mostly new runtime system to do graphics,
paddles, vt-100 terminal emulation etc, overlapping with NABU-LIB quite a lot.
So either use the old Z88DK and NABU-LIB or use the newer Z88DK runtime without
NABU-LIB.

<P>Compile <I>Brick Battle</I>, read the game code, look at compiler output
(array access gets simpler if player array structures are 8 bytes rather than 5
bytes), hack it up a bit.

<H2>2024.03.11</H2>

<H3>NABU-LIB Functionality?</H3>

<P>Read source code for NABU-LIB and see what functionality it provides:

<UL>
  <LI>NabuTracker - Music from MIDI files, 2 note channels and one noise or
    note channel.  Each note specifies beat #, on/off, channel, pitch, volume.
    Update function called every 1/16 note time (processes all notes with same
    beat number).  C# utility to convert .mid files to NabuTracker source code
    format.
  <LI>Lots of remote commands to the Internet Adapter to open files
    (rn_fileOpen etc), network connections and URLs to read or write them.
    Might be dependent on using the Nabu.ca Internet Adapter software as the
    server side for that extra functionality.  Also CP/M virtual remote disk
    support, which you'd access via the usual CP/M APIs.
  <LI>Font loading (as data in a header file) for text and graphics modes, with
    several fonts to choose from.  Also terminal emulation with cursor, so you
    can print to the screen without using CP/M.
  <LI>Text mode double buffer in main RAM, so only changes have to be copied to
    the slow VDP memory.  Also implements a cursor and scrolling.  And a hook
    into the BIOS CP/M cursor position get/set, and the whole suite of VT52
    operations (clear to end of line, etc).
  <LI>VDP init in various modes, load patterns, print text, draw high-res dots,
    move sprites.  Some assumptions such as sprites not animated (same pattern
    name for a given sprite ID).
  <LI>Keyboard access, isKeyPressed() is non-blocking.  Also get a character or
    a line.
  <LI>Non-blocking Joystick access.
  <LI>Can add VDP interrupt handlers.  Buffered VDP interrupt enable register
    (the real one is write only).  Other registers are also buffered in CPU
    RAM.
  <LI>Can create programs for homebrew mode (your program + NABULIB controls
    the hardware directly) or CP/M mode or a mixture.
  <LI>Can turn off various features to save space if you don't need them.
  <LI>Has a debug feature to see if your code takes more than one frame to run.
  <LI>Music - can play a note (has a table of MIDI notes to frequency codes).
    Also low level AY-3-8910 programmable sound generator chip access.
  <LI>Support for regular NABU interrupt system.
  <LI>Access the HCCA (Home Cable Computer Adapter) network interface.
    Background interrupt to fill a receive buffer, API to get buffer contents.
    Glue functions to get/send data as various size/sign integers.
</UL>

<H2>2024.03.17</H2>

<P>Continue reading NABU-LIB.h at line 344, VDP Variables.

<H2>2024.03.20</H2>

<P>Continue reading NABU-LIB.h at line 1077, VDP functions.  Finished .h, and
then read NABU-LIB.c, with a side trip to check out how RetroNET-FileStore.*
works (writes and reads codes over the HCCA serial port to the server to open
files, etc, on the server and use a handle number to refer to them on the
NABU).  Overall, several copy and paste documentation errors, works as expected
and not super optimised so it's understandable.

<H2>2024.03.29</H2>

<H3>Z88DK NABU Support?</H3>

<P>Want to look at the zcc compiler NABU support.  Start by getting latest zcc
source and compiling the compiler.  It uses zsdcc_r14648_src.tar.gz for the
underlying compiler.  Then search for files with "nabu" in them.  See
z88dk/include/arch/nabu.h and directory z88dk/include/arch/nabu/.

<UL>
  <LI>Has TMS9918 video code for graphics and terminal text displays, actually
    a library written for some other computer, goes up to 3D flat shaded
    polygons.
  <LI>Functions for accessing the HCCA network, with interrupt driven reads (to
    a ring buffer) and writes.
  <LI>Interrupt system glue code, and keyboard+joystick+paddle and VDP
    interrupt handling.
  <LI>Sound generator API, but no music player.
  <LI>Includes RetroNet API for remote file & URL access.  See files in
    z88dk/libsrc/target/nabu/retronet/
  <LI>Lots of examples, 2 NABU specific (RetroNet test, input test), rest are
    MSX ones, like slowly using lines to draw an Earth globe, or a spaceship
    that shoots while over a colourful scrolling river background, or a Tron
    light cycle game (Snakes) with sound.
  <LI>Has various number libraries, from F48 floating point to 16 bit fixed
    point.  And matrix operations from the 3D library which adapts to use
    whatever underlying number system you use for your math library (see
    z88dk/include/lib3d.h).
</UL>

<H2>2024.04.07</H2>

<P>So, best bet for portability and future compilation is to use Z88DK NABU
support and the newer compiler.  But keep an eye on NABU-LIB for useful code.

<H3>Game Design</H3>

<P>Next up - game design.  What do I want in the game?

<UL>
  <LI>Nth Pong Wars stand-alone operation with zero players, just as a kind of
    screen saver and initial proof of concept.
  <LI>Have N balls of different colours, maybe limit it to 4 due to NABU sprite
    limits.  Also allow different sized balls, useful for bonus effects.
  <LI>Tiles are done as 8x8 pixel character blocks.  Top row on the screen is
    reserved for score, so 32 wide x 23 tall tiles = 736 tiles.  Each tile shows
    the current owner's colour and maybe fade or modify to show other tile
    properties, like power-ups.
  <LI>Score.  Count of number of tiles owned by each colour.  Displayed in the
    background layer, 4 numbers each 3 digits and a space in player's colour
    across the top of the screen.  Tile count or percentage of total tiles or
    both or a menu option?
  <LI>Idea from Atari 2600 version - a score limit, game over when the highest
    player tile count reaches the limit.  Optionally, the limit slowly
    decreases over time, adding a sense of urgency to playing the game.
    Display the limit on the score row too.
  <LI>Main menu to choose options.  Save options to a settings file.
  <LI>High score table.  Ask for initials.  Store in a CP/M file on C: drive
    since that's the writable drive.  Date stamp too so they know when they last
    played or can show all-time, yearly, monthly, weekly, daily, hourly champs.
    Maybe also share the high scores across the network and have regional
    high score boards too.  But don't show too many boards, just the ones the
    players are interested in (ones they are on).
  <LI>Player interaction.  Use the joystick to add some acceleration to a
    particular ball, multiple player support (up to 4 joysticks).  Fire button
    activates special effects when held down.
  <LI>AI players for unassigned balls (if no joystick inputs after a while, the
    AI takes over).
  <LI>Network play, up to 4 players total, with 0 to 4 per computer (so you can
    have spectators), dynamic joining and leaving the game with AI players
    taking over when joystick operators are away.
  <LI>Staleness.  After time the tiles fade to a background colour.  Maybe even
    vanish back to neutral, or to the worst player's colour to give them a
    boost?
  <LI>Burn some of your tiles to do special effects, like have a larger ball or
    more acceleration when using the joystick.  Perhaps have power-up bonuses
    that change the special effect when you run over them.
  <LI>Sound effects for collisions, ball-ball and ball-tile.  Maybe vary a bit
    in pitch to reflect player's number.  Secondary sound effects for burning
    tiles (affected by player), accelerating (player and acceleration direction
    influence it).  Allow stacking of sound effects so several things happening
    at once play out.
  <LI>Background music, probably not possible in the game on the NABU with all
    those sound effects, but definitely for the menus.
</UL>

<H3>Code Design</H3>

<P>Possible ways of implementing the game design.

<UL>
  <LI>Portable core code in C so it can run on other computer system types,
    like BeOS or Linux.  The simulation code, game state and network protocol
    should be the same for all platforms for portability reasons.
  <LI>Allow for other screen sizes for running on other computer system
    types or as a game variation on the NABU.  NABU may be able to keep track
    of larger playfields if there is enough memory, but only show a window into
    the larger area (perhaps following the active players center of mass).
  <LI>Design for network play, one main computer controls the game, clients
    forward joystick inputs.  Main computer sends out a data dump every once in
    a while (ideally every frame) with a list of state changes (a small list is
    good for VDP and network bandwidth limits).
  <LI>Dynamically add and remove remote players.  Clients can send special
    opcodes to request the whole screen when joining the game, or a copy of the
    game state data in case they want to take over running the game.
  <LI>Dynamically add and remove local players.  Have AI take over or delete
    idle players (get down to a two player screensaver game if idle long
    enough).  Possibly this means that the menu doesn't ask for the number of
    players, just add a ball if joystick activity is detected.
  <LI>Use graphics I mode, so changing a tile is just a single byte write,
    though will need to duplicate the score digits with different colours for
    each set.  Also have ASCII font in white and the tiles in each of 4
    colours.  Maybe also have faded tiles (done with dithering) since we have 8
    tiles per colour palette entry.  And power-up tiles.  Or use multicolour
    mode 64x46 tiles and display score with sprites.
  <LI>Balls are done with sprites, up to 16x16, one sprite per ball.  Or maybe
    have a second one for a shadow, but use lower priority ones for that to
    avoid having the ball flicker.  Also have balls from 1 pixel to 16 pixels
    in diameter.  Ball image is left and top justified within the sprite
    rectangle.  Maybe also show power-up effects by changing ball graphics,
    perhaps animating them?  Though for the large ball power-up, it's self
    evident.
  <LI>Use fractional 16 bit integers (2's complement sign + 9 bit integer +
    6 bit fraction, values up to 511 + 63/64th) for velocity and position in
    pixels per frame.  Need a bit more than 256 since the NABU screen is 256
    pixels wide.  Implies maximum game board size is 63 tiles tall or wide.
  <LI>Coordinate system uses pixels, zero based like the Macintosh (not BeOS
    which awkwardly used centers of pixels for integer coordinate points), top
    left corner of pixel is (0,0), x increases to right, y increases down,
    bottom right pixel corner is (1,1), tiles cover 8 pixels, tile center is at
    (4.0, 4.0) with four pixels on either side of the center.
  <LI>Simulation math.  Need collision detection between ball and ball or ball
    and tile.  Start with ad-hoc like the other examples use, then move to ball
    as a circle intersecting tile rectangles.  Handle multiple tile
    intersections per frame by considering shape of circle moving through space
    to figure which tile it hits first, then bounce off tile and consider next
    collision, until ball has moved its whole frame velocity distance.<BR>
    Hmmm, rather than calculating edge collisions and dot products, find the
    tiles under the current ball shape (ball size can vary, tile center distance
    to ball center has to be less than ball radius + tile radius) and find
    them all.  If they are the player's colour already, no change needed.  Other
    tiles get owned by the player and also affect the ball motion.  Make a 2D
    net vector sum of all the non-player tiles relative to the ball center, and
    use that to bounce (reflect, reverse) the ball velocity component that's in
    the same direction.  Can be a classic bounce, or if there is a ball push
    through obstacles power-up active, it just adds friction proportional to the
    vector length.  And of course, classic bounce off the board edge.  And ball
    on ball collision detection and resulting explosions.
  <LI>Fractional movement math (use 16 bit fixed point numbers), so can move
    faster than 1 square per frame.  Makes collision detection more
    complicated, can hit several tiles in one frame.  So do the simulation in
    smaller steps than a single frame, moving the balls in steps of at
    most half a tile at a time (fastest ball moves half a tile, others move
    proportionally slower), then redoing collision tests (don't want to do one
    ball then the others, want to detect mutual ball collisions more
    realistically).  Repeat until the balls have all moved their velocity per
    frame distance.  That way the ball won't skip over tiles if it is going too
    fast.
  <LI>Keep track of each player's tiles in a queue so we can burn their oldest
    tiles as needed.  Linked list would be best, since we have to remove tiles
    in the middle as the opponents take them.  Each global tile record would
    have a forward and back pointer.  Burnt tiles can turn into empty tiles or
    into power-ups.
  <LI>After the simulation update for a frame has been done to the in-memory
    tile and ball state, go through and extract a list of changes, using
    opcodes (like tile position & new colour, ball position, score change,
    sound effect) and then send it out to clients and also run it against our
    own VDP.  Clients send back a similar list of opcodes for joystick and
    other inputs.
</UL>

<H2>2024.04.14</H2>

<P>Yet more game design, and code design, they're kind of a continuum of design
and not really separate.  Stealing lots of ideas, and coming up with a few
new variations.

<H2>2024.04.16</H2>

<P>Wonder how well you can do 16 bit fixed point integers on the Z80, what does
the generated code look like?

<P>Write some test code, we have a 6 bit fraction and 10 bit integer part,
adding works by just using signed 16 bit integers, but we need to divide by 64
to get the integer portion.

<H2>2024.04.21</H2>

<P>Continue with fixed point speed tests, trying to get the compiler to not
optimise everything out by putting the code in a subroutine with arguments,
rather than in-line with constants.

<P>Ugh, divide a 16 bit integer by 64 is <CODE>sra d; rr e;</CODE> repeated 6
times, totalling 24 bytes of opcodes.  Floating point is even worse, with lots
of code to just put the 4 byte arguments on the stack to set up a library call.

<P>Comparing against 2 byte integers, it looks like 4 byte integers take twice
as long, and 4 byte floating point numbers take 8 times longer.  Since it's
kind of non-standard to use 16 bit fixed point other than 8.8 bits (we want
10.6 for pixel coordinates), 32 bit integers in a 16.16 fixed point format
would be safer and easier for the computer to shift to get the integer or
fraction portion.  32 bit integers will give us enough numeric range and be
well supported on all computers.

<P>But how fast is math on the Z80?  2 seconds for 50000 calls to a subroutine
that adds two 16 bit ints, 4 seconds for 32 bit ints, 15 seconds for 32 bit
floats.  Yes, there is some loop and subroutine call overhead, but that's close
enough for estimates.

<P>So, how much math do we need?  Most is collision detection, finding the
tiles inside a circle around a ball.  The biggest ball is 32 pixels in
diameter, so 4x4 tiles or 16 tiles (well, maybe 5x5 for half tiles around the
edge).  Distance from a tile to ball would be an (X, Y) vector, so 2
subtractions to calculate it.  Can use a table to go from X (varies from 0 to
ball radius plus tile radius = 20) to X squared (whew, expensive multiplication
avoided), one more addition to add X^2 + Y^2 to get distance squared (avoid
doing square root, work with squared pixel length) and a subtraction to do the
comparison (<B>draw tiles as circles to match the math and look better</B> -
in-joke: have a spherical cow Easter egg).  So 4 add/subtracts per tile, 16
times, totalling 64 additions per ball.  4 balls, so 256 additions.  60 frames
per second, so 15360 additions per second just for tile collisions.  And we can
do 25000 additions per second for 16 bit math, or 12500 for 32 bit integers.
Looks like we should use 16 bit integers to be safe, or use 32 and run at 30
frames per second.

<P>So start with 32 bit fixed point math and allow for the possibility of
rewriting as 16 bit if we don't have enough speed.

<H2>2024.04.25</H2>

<P>Looked at ncurses, seems like it could show the tile field quite easily for Linux and BeOS in terminal mode, since it renders an array of characters to a screen.  Also has support for menus and windows.  Should be easier to debug in a terminal in a modern OS rather than on a NABU screen.  Nobody uses ncurses on Z88DK since the library is several kilobytes large.

<P>Spent a while trying to get ncurses to do anything, turns out you need to read a character else it doesn't draw anything (or it draws and erases it too quickly to see it).  Also, can do colour, which will be good for the game!

<H2>2024.05.01</H2>

<P>Code just a ball bouncing off the walls, to get started.  Uses ncurses for output, keyboard for input, should compile in Linux and then BeOS.

<P>Yeah!  It works.  The 16.16 bit fixed point math seems to work correctly, and I got ncurses running in real time (specified as 20 frames per second) and in colour.

<P ALIGN=CENTER><IMG SRC="Pong_Wars_NCurses_and_Math_Test_20240501.png"
ALT="[Screen shot of Pong Wars test by Alexander G. M. Smith, May 1, 2024, showing working fixed point math and ncurses input and output]" WIDTH="512"
HEIGHT="432">

<P>You can also see the <A HREF="main_20240501.c">source code in C</A> for this version.

<P>Next up, design the main data structures for the balls and tiles.  And algorithms for evenly advancing positions of multiple balls moving faster than one tile per frame.  Hmmm, might also need a sorted tree of tile updates to find runs of changes for faster NABU VDP video chip writes and better network data compression.

<P>- Alex

<P ALIGN="CENTER">Copyright &copy; 2024 by Alexander G. M. Smith.
</BODY>
</HTML>
